<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>attrbox.config API documentation</title>
<meta name="description" content="Configuration loading and parsing." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>attrbox.config</code></h1>
</header>
<section id="section-intro">
<p>Configuration loading and parsing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Configuration loading and parsing.&#34;&#34;&#34;

# native
from inspect import cleandoc
from pathlib import Path
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Union
import json

# lib
from docopt import docopt
import tomli as tomllib  # TODO 2026-10-04 [3.10 EOL]: switch to native tomllib

# pkg
from .attrdict import AttrDict
from . import env

PYTHON_KEYWORDS: List[
    str
] = &#34;&#34;&#34;\
    False      await      else       import     pass
    None       break      except     in         raise
    True       class      finally    is         return
    and        continue   for        lambda     try
    as         def        from       nonlocal   while
    assert     del        global     not        with
    async      elif       if         or         yield
&#34;&#34;&#34;.lower().split()
&#34;&#34;&#34;[All Python keywords](https://docs.python.org/3/reference/lexical_analysis.html#keywords).&#34;&#34;&#34;

LoaderFunc = Callable[[str], Any]
&#34;&#34;&#34;Function signature to load configuration from a string.&#34;&#34;&#34;

LOADERS: Dict[str, LoaderFunc] = {}
&#34;&#34;&#34;Mapping of file extensions to configuration loaders.&#34;&#34;&#34;


def set_loader(suffix: str, loader: LoaderFunc) -&gt; None:
    &#34;&#34;&#34;Register a configuration `loader` for a given file `suffix`.

    NOTE: This will overwrite any previously registered loader for `suffix`.

    Args:
        suffix (str): file suffix with the leading period (e.g., `&#34;.json&#34;`)

        loader (LoaderFunc): function that takes a string and returns
            an object, typically a `Dict[str, Any]` of key/value pairs.
    &#34;&#34;&#34;
    LOADERS[suffix] = loader


set_loader(&#34;.json&#34;, json.loads)
set_loader(&#34;.toml&#34;, tomllib.loads)
set_loader(&#34;.env&#34;, env.loads)
# loaders registered


def load_config(
    path: Path,
    /,
    *,
    load_imports: bool = True,
    loaders: Optional[Mapping[str, LoaderFunc]] = None,
    done: Optional[List[Path]] = None,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Load a configuration file from `path` using configuration `loaders`.

    Args:
        path (Path): file to load.

        load_imports (bool, optional): If `True`, recursively load any files
            located at the `imports` key. Defaults to `True`.

        loaders (Mapping[str, LoaderFunc], optional): mapping of file suffixes
            to to loader functions. If `None`, uses the global `LOADERS`.
            Defaults to `None`.

        done (List[Path], optional): If provided, a list of paths to ignore when
            doing recursive loading. Defaults to `None`.

    Returns:
        Dict[str, Any]: keys/values from the configuration file

    Examples:
        &gt;&gt;&gt; root = Path(__file__).parent.parent.parent
        &gt;&gt;&gt; expected = {&#39;section&#39;: {&#39;key&#39;: &#39;value1&#39;, &#34;env&#34;: &#34;loaded&#34;,
        ... &#34;json&#34;: &#34;loaded&#34;, &#34;toml&#34;: &#34;loaded&#34;}}
        &gt;&gt;&gt; load_config(root / &#34;test/config_1.toml&#34;) == expected
        True
    &#34;&#34;&#34;
    result = AttrDict()
    path = path.resolve()
    done = done or []

    loader = (loaders or LOADERS)[path.suffix]
    data = loader(path.read_text())
    if load_imports and &#34;imports&#34; in data:
        imports = [(path.parent / p).resolve() for p in data.pop(&#34;imports&#34;)]
        for file in imports:
            if file in done:
                continue

            result &lt;&lt;= load_config(
                file,
                load_imports=True,
                loaders=loaders,
                done=done + imports,
            )
    result &lt;&lt;= data
    return result


def optvar(
    name: str,
    /,
    *,
    shadow_keywords: bool = False,
    shadow_builtins: bool = False,
) -&gt; str:
    &#34;&#34;&#34;Return a valid python variable name from a docopt flag.

    Args:
        name (str): docopt option name.

        shadow_keywords (bool, optional): If `True`, allow `name` to be a
            python keyword. Otherwise, add an underscore. Defaults to `False`.

        shadow_builtins (bool, optional): If `True` allow `name` to be a name
            of a python `builtins` (globally available names). Otherwise, add an
            underscore. Defaults to `False`.

    Returns:
        str: option name converted to a valid python variable name

    Examples:
        Special cases:
        &gt;&gt;&gt; optvar(&#34;-&#34;) == &#34;stdin&#34;
        True
        &gt;&gt;&gt; optvar(&#34;--&#34;) == &#34;__&#34;
        True

        Leading dashes removed:
        &gt;&gt;&gt; optvar(&#34;--example&#34;) == &#34;example&#34;
        True
        &gt;&gt;&gt; optvar(&#34;-v&#34;) == &#34;v&#34;
        True

        Hyphens become underscores:
        &gt;&gt;&gt; optvar(&#34;--two-words&#34;) == &#34;two_words&#34;
        True

        Angle brackets removed:
        &gt;&gt;&gt; optvar(&#34;&lt;file&gt;&#34;) == &#34;file&#34;
        True

        By default, we don&#39;t shadow keywords or builtins:
        &gt;&gt;&gt; optvar(&#34;--continue&#34;) == &#34;continue_&#34;
        True
        &gt;&gt;&gt; optvar(&#34;--help&#34;) == &#34;help_&#34;
        True

        Shadow builtins if you want:
        &gt;&gt;&gt; optvar(&#34;--list&#34;, shadow_builtins=True) == &#34;list&#34;
        True

        Shadow keywords at your own risk:
        &gt;&gt;&gt; optvar(&#34;--continue&#34;, shadow_keywords=True) == &#34;continue&#34;
        True
    &#34;&#34;&#34;
    result = name.lower()
    special = {&#34;-&#34;: &#34;stdin&#34;, &#34;--&#34;: &#34;__&#34;}
    if result in special:
        return special[result]
    # special cases handled

    result = result.replace(&#34;--&#34;, &#34;&#34;)
    if result[0] == &#34;-&#34;:
        result = result[1:]
    # leading hyphens removed

    trans: Dict[str, Union[str, int, None]] = {&#34;-&#34;: &#34;_&#34;, &#34;&lt;&#34;: &#34;&#34;, &#34;&gt;&#34;: &#34;&#34;}
    result = result.translate(str.maketrans(trans))
    # hyphens become underscores; angle brackets removed

    if not shadow_keywords and result in PYTHON_KEYWORDS:
        result += &#34;_&#34;
        # don&#39;t shadow keywords

    if not shadow_builtins:
        built_in = [s.lower() for s in globals()[&#34;__builtins__&#34;]]
        if result in built_in:
            result += &#34;_&#34;
        # don&#39;t shadow builtins

    return result


def parse_docopt(
    doc: str,
    /,
    argv: Optional[Sequence[str]] = None,
    *,
    version: str = &#34;1.0.0&#34;,
    options_first: bool = False,
    read_config: bool = True,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Parse docopt args and load config.

    Args:
        doc (str): docstring with description of command

        argv (Sequence[str], optional): arguments to parse against the
            doc. If `None`, will default to `sys.argv[1:]`. Defaults to `None`.

        version (str, optional): program version. Defaults to `&#34;1.0.0&#34;`.

        options_first (bool): If `True`, options must come before positional
            arguments. Defaults to `False`.

        read_config (bool): If `True`, a `&lt;config&gt;` argument or `--config` option
            will be automatically loaded before args are parsed. Defaults to `True`.

    Returns:
        Dict[str, Any]: mapping of options to values

    Examples:
        &gt;&gt;&gt; usage = &#34;Usage: test.py [--debug]&#34;
        &gt;&gt;&gt; parse_docopt(usage, argv=[&#34;--debug&#34;])
        {&#39;debug&#39;: True}

        &gt;&gt;&gt; root = Path(__file__).parent.parent.parent
        &gt;&gt;&gt; path = str(root / &#34;test/config_1.toml&#34;)
        &gt;&gt;&gt; usage = &#34;Usage: test.py &lt;config&gt; [--section.key=VAL]&#34;
        &gt;&gt;&gt; argv = [path, &#34;--section.key=overwrite&#34;]
        &gt;&gt;&gt; expected = {&#34;section&#34;: {
        ...     &#34;key&#34;: &#34;overwrite&#34;, # overwritten by argv
        ...     &#34;env&#34;: &#34;loaded&#34;, &#34;json&#34;: &#34;loaded&#34;, &#34;toml&#34;: &#34;loaded&#34;
        ... }, &#34;config&#34;: path}
        &gt;&gt;&gt; parse_docopt(usage, argv=argv) == expected
        True
    &#34;&#34;&#34;
    result = AttrDict()
    args = {
        optvar(k, shadow_builtins=True): v
        for k, v in docopt(
            cleandoc(doc),
            argv=argv,
            help=True,
            version=version,
            options_first=options_first,
        ).items()
    }

    if read_config and &#34;config&#34; in args:
        result &lt;&lt;= load_config(Path(args[&#34;config&#34;]))

    for key, val in args.items():
        key = optvar(key, shadow_builtins=True)
        result[key.split(&#34;.&#34;)] = val
    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="attrbox.config.PYTHON_KEYWORDS"><code class="name">var <span class="ident">PYTHON_KEYWORDS</span> : List[str]</code></dt>
<dd>
<div class="desc"><p><a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">All Python keywords</a>.</p></div>
</dd>
<dt id="attrbox.config.LoaderFunc"><code class="name">var <span class="ident">LoaderFunc</span></code></dt>
<dd>
<div class="desc"><p>Function signature to load configuration from a string.</p></div>
</dd>
<dt id="attrbox.config.LOADERS"><code class="name">var <span class="ident">LOADERS</span> : Dict[str, Callable[[str], Any]]</code></dt>
<dd>
<div class="desc"><p>Mapping of file extensions to configuration loaders.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="attrbox.config.set_loader"><code class="name flex">
<span>def <span class="ident">set_loader</span></span>(<span>suffix: str, loader: Callable[[str], Any]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Register a configuration <code>loader</code> for a given file <code>suffix</code>.</p>
<p>NOTE: This will overwrite any previously registered loader for <code>suffix</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>file suffix with the leading period (e.g., <code>".json"</code>)</dd>
<dt><strong><code>loader</code></strong> :&ensp;<code><a title="attrbox.config.LoaderFunc" href="#attrbox.config.LoaderFunc">LoaderFunc</a></code></dt>
<dd>function that takes a string and returns
an object, typically a <code>Dict[str, Any]</code> of key/value pairs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_loader(suffix: str, loader: LoaderFunc) -&gt; None:
    &#34;&#34;&#34;Register a configuration `loader` for a given file `suffix`.

    NOTE: This will overwrite any previously registered loader for `suffix`.

    Args:
        suffix (str): file suffix with the leading period (e.g., `&#34;.json&#34;`)

        loader (LoaderFunc): function that takes a string and returns
            an object, typically a `Dict[str, Any]` of key/value pairs.
    &#34;&#34;&#34;
    LOADERS[suffix] = loader</code></pre>
</details>
</dd>
<dt id="attrbox.config.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>path: pathlib.Path, /, *, load_imports: bool = True, loaders: Optional[Mapping[str, Callable[[str], Any]]] = None, done: Optional[List[pathlib.Path]] = None) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a configuration file from <code>path</code> using configuration <code>loaders</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>file to load.</dd>
<dt><strong><code>load_imports</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, recursively load any files
located at the <code>imports</code> key. Defaults to <code>True</code>.</dd>
<dt><strong><code>loaders</code></strong> :&ensp;<code>Mapping[str, <a title="attrbox.config.LoaderFunc" href="#attrbox.config.LoaderFunc">LoaderFunc</a>]</code>, optional</dt>
<dd>mapping of file suffixes
to to loader functions. If <code>None</code>, uses the global <code><a title="attrbox.config.LOADERS" href="#attrbox.config.LOADERS">LOADERS</a></code>.
Defaults to <code>None</code>.</dd>
<dt><strong><code>done</code></strong> :&ensp;<code>List[Path]</code>, optional</dt>
<dd>If provided, a list of paths to ignore when
doing recursive loading. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Any]</code></dt>
<dd>keys/values from the configuration file</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; root = Path(__file__).parent.parent.parent
&gt;&gt;&gt; expected = {'section': {'key': 'value1', &quot;env&quot;: &quot;loaded&quot;,
... &quot;json&quot;: &quot;loaded&quot;, &quot;toml&quot;: &quot;loaded&quot;}}
&gt;&gt;&gt; load_config(root / &quot;test/config_1.toml&quot;) == expected
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(
    path: Path,
    /,
    *,
    load_imports: bool = True,
    loaders: Optional[Mapping[str, LoaderFunc]] = None,
    done: Optional[List[Path]] = None,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Load a configuration file from `path` using configuration `loaders`.

    Args:
        path (Path): file to load.

        load_imports (bool, optional): If `True`, recursively load any files
            located at the `imports` key. Defaults to `True`.

        loaders (Mapping[str, LoaderFunc], optional): mapping of file suffixes
            to to loader functions. If `None`, uses the global `LOADERS`.
            Defaults to `None`.

        done (List[Path], optional): If provided, a list of paths to ignore when
            doing recursive loading. Defaults to `None`.

    Returns:
        Dict[str, Any]: keys/values from the configuration file

    Examples:
        &gt;&gt;&gt; root = Path(__file__).parent.parent.parent
        &gt;&gt;&gt; expected = {&#39;section&#39;: {&#39;key&#39;: &#39;value1&#39;, &#34;env&#34;: &#34;loaded&#34;,
        ... &#34;json&#34;: &#34;loaded&#34;, &#34;toml&#34;: &#34;loaded&#34;}}
        &gt;&gt;&gt; load_config(root / &#34;test/config_1.toml&#34;) == expected
        True
    &#34;&#34;&#34;
    result = AttrDict()
    path = path.resolve()
    done = done or []

    loader = (loaders or LOADERS)[path.suffix]
    data = loader(path.read_text())
    if load_imports and &#34;imports&#34; in data:
        imports = [(path.parent / p).resolve() for p in data.pop(&#34;imports&#34;)]
        for file in imports:
            if file in done:
                continue

            result &lt;&lt;= load_config(
                file,
                load_imports=True,
                loaders=loaders,
                done=done + imports,
            )
    result &lt;&lt;= data
    return result</code></pre>
</details>
</dd>
<dt id="attrbox.config.optvar"><code class="name flex">
<span>def <span class="ident">optvar</span></span>(<span>name: str, /, *, shadow_keywords: bool = False, shadow_builtins: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a valid python variable name from a docopt flag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>docopt option name.</dd>
<dt><strong><code>shadow_keywords</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, allow <code>name</code> to be a
python keyword. Otherwise, add an underscore. Defaults to <code>False</code>.</dd>
<dt><strong><code>shadow_builtins</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code> allow <code>name</code> to be a name
of a python <code>builtins</code> (globally available names). Otherwise, add an
underscore. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>option name converted to a valid python variable name</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Special cases:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;-&quot;) == &quot;stdin&quot;
True
&gt;&gt;&gt; optvar(&quot;--&quot;) == &quot;__&quot;
True
</code></pre>
<p>Leading dashes removed:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;--example&quot;) == &quot;example&quot;
True
&gt;&gt;&gt; optvar(&quot;-v&quot;) == &quot;v&quot;
True
</code></pre>
<p>Hyphens become underscores:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;--two-words&quot;) == &quot;two_words&quot;
True
</code></pre>
<p>Angle brackets removed:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;&lt;file&gt;&quot;) == &quot;file&quot;
True
</code></pre>
<p>By default, we don't shadow keywords or builtins:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;--continue&quot;) == &quot;continue_&quot;
True
&gt;&gt;&gt; optvar(&quot;--help&quot;) == &quot;help_&quot;
True
</code></pre>
<p>Shadow builtins if you want:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;--list&quot;, shadow_builtins=True) == &quot;list&quot;
True
</code></pre>
<p>Shadow keywords at your own risk:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; optvar(&quot;--continue&quot;, shadow_keywords=True) == &quot;continue&quot;
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optvar(
    name: str,
    /,
    *,
    shadow_keywords: bool = False,
    shadow_builtins: bool = False,
) -&gt; str:
    &#34;&#34;&#34;Return a valid python variable name from a docopt flag.

    Args:
        name (str): docopt option name.

        shadow_keywords (bool, optional): If `True`, allow `name` to be a
            python keyword. Otherwise, add an underscore. Defaults to `False`.

        shadow_builtins (bool, optional): If `True` allow `name` to be a name
            of a python `builtins` (globally available names). Otherwise, add an
            underscore. Defaults to `False`.

    Returns:
        str: option name converted to a valid python variable name

    Examples:
        Special cases:
        &gt;&gt;&gt; optvar(&#34;-&#34;) == &#34;stdin&#34;
        True
        &gt;&gt;&gt; optvar(&#34;--&#34;) == &#34;__&#34;
        True

        Leading dashes removed:
        &gt;&gt;&gt; optvar(&#34;--example&#34;) == &#34;example&#34;
        True
        &gt;&gt;&gt; optvar(&#34;-v&#34;) == &#34;v&#34;
        True

        Hyphens become underscores:
        &gt;&gt;&gt; optvar(&#34;--two-words&#34;) == &#34;two_words&#34;
        True

        Angle brackets removed:
        &gt;&gt;&gt; optvar(&#34;&lt;file&gt;&#34;) == &#34;file&#34;
        True

        By default, we don&#39;t shadow keywords or builtins:
        &gt;&gt;&gt; optvar(&#34;--continue&#34;) == &#34;continue_&#34;
        True
        &gt;&gt;&gt; optvar(&#34;--help&#34;) == &#34;help_&#34;
        True

        Shadow builtins if you want:
        &gt;&gt;&gt; optvar(&#34;--list&#34;, shadow_builtins=True) == &#34;list&#34;
        True

        Shadow keywords at your own risk:
        &gt;&gt;&gt; optvar(&#34;--continue&#34;, shadow_keywords=True) == &#34;continue&#34;
        True
    &#34;&#34;&#34;
    result = name.lower()
    special = {&#34;-&#34;: &#34;stdin&#34;, &#34;--&#34;: &#34;__&#34;}
    if result in special:
        return special[result]
    # special cases handled

    result = result.replace(&#34;--&#34;, &#34;&#34;)
    if result[0] == &#34;-&#34;:
        result = result[1:]
    # leading hyphens removed

    trans: Dict[str, Union[str, int, None]] = {&#34;-&#34;: &#34;_&#34;, &#34;&lt;&#34;: &#34;&#34;, &#34;&gt;&#34;: &#34;&#34;}
    result = result.translate(str.maketrans(trans))
    # hyphens become underscores; angle brackets removed

    if not shadow_keywords and result in PYTHON_KEYWORDS:
        result += &#34;_&#34;
        # don&#39;t shadow keywords

    if not shadow_builtins:
        built_in = [s.lower() for s in globals()[&#34;__builtins__&#34;]]
        if result in built_in:
            result += &#34;_&#34;
        # don&#39;t shadow builtins

    return result</code></pre>
</details>
</dd>
<dt id="attrbox.config.parse_docopt"><code class="name flex">
<span>def <span class="ident">parse_docopt</span></span>(<span>doc: str, /, argv: Optional[Sequence[str]] = None, *, version: str = '1.0.0', options_first: bool = False, read_config: bool = True) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse docopt args and load config.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong> :&ensp;<code>str</code></dt>
<dd>docstring with description of command</dd>
<dt><strong><code>argv</code></strong> :&ensp;<code>Sequence[str]</code>, optional</dt>
<dd>arguments to parse against the
doc. If <code>None</code>, will default to <code>sys.argv[1:]</code>. Defaults to <code>None</code>.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>program version. Defaults to <code>"1.0.0"</code>.</dd>
<dt><strong><code>options_first</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, options must come before positional
arguments. Defaults to <code>False</code>.</dd>
<dt><strong><code>read_config</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, a <code>&lt;config&gt;</code> argument or <code>--config</code> option
will be automatically loaded before args are parsed. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Any]</code></dt>
<dd>mapping of options to values</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; usage = &quot;Usage: test.py [--debug]&quot;
&gt;&gt;&gt; parse_docopt(usage, argv=[&quot;--debug&quot;])
{'debug': True}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; root = Path(__file__).parent.parent.parent
&gt;&gt;&gt; path = str(root / &quot;test/config_1.toml&quot;)
&gt;&gt;&gt; usage = &quot;Usage: test.py &lt;config&gt; [--section.key=VAL]&quot;
&gt;&gt;&gt; argv = [path, &quot;--section.key=overwrite&quot;]
&gt;&gt;&gt; expected = {&quot;section&quot;: {
...     &quot;key&quot;: &quot;overwrite&quot;, # overwritten by argv
...     &quot;env&quot;: &quot;loaded&quot;, &quot;json&quot;: &quot;loaded&quot;, &quot;toml&quot;: &quot;loaded&quot;
... }, &quot;config&quot;: path}
&gt;&gt;&gt; parse_docopt(usage, argv=argv) == expected
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_docopt(
    doc: str,
    /,
    argv: Optional[Sequence[str]] = None,
    *,
    version: str = &#34;1.0.0&#34;,
    options_first: bool = False,
    read_config: bool = True,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Parse docopt args and load config.

    Args:
        doc (str): docstring with description of command

        argv (Sequence[str], optional): arguments to parse against the
            doc. If `None`, will default to `sys.argv[1:]`. Defaults to `None`.

        version (str, optional): program version. Defaults to `&#34;1.0.0&#34;`.

        options_first (bool): If `True`, options must come before positional
            arguments. Defaults to `False`.

        read_config (bool): If `True`, a `&lt;config&gt;` argument or `--config` option
            will be automatically loaded before args are parsed. Defaults to `True`.

    Returns:
        Dict[str, Any]: mapping of options to values

    Examples:
        &gt;&gt;&gt; usage = &#34;Usage: test.py [--debug]&#34;
        &gt;&gt;&gt; parse_docopt(usage, argv=[&#34;--debug&#34;])
        {&#39;debug&#39;: True}

        &gt;&gt;&gt; root = Path(__file__).parent.parent.parent
        &gt;&gt;&gt; path = str(root / &#34;test/config_1.toml&#34;)
        &gt;&gt;&gt; usage = &#34;Usage: test.py &lt;config&gt; [--section.key=VAL]&#34;
        &gt;&gt;&gt; argv = [path, &#34;--section.key=overwrite&#34;]
        &gt;&gt;&gt; expected = {&#34;section&#34;: {
        ...     &#34;key&#34;: &#34;overwrite&#34;, # overwritten by argv
        ...     &#34;env&#34;: &#34;loaded&#34;, &#34;json&#34;: &#34;loaded&#34;, &#34;toml&#34;: &#34;loaded&#34;
        ... }, &#34;config&#34;: path}
        &gt;&gt;&gt; parse_docopt(usage, argv=argv) == expected
        True
    &#34;&#34;&#34;
    result = AttrDict()
    args = {
        optvar(k, shadow_builtins=True): v
        for k, v in docopt(
            cleandoc(doc),
            argv=argv,
            help=True,
            version=version,
            options_first=options_first,
        ).items()
    }

    if read_config and &#34;config&#34; in args:
        result &lt;&lt;= load_config(Path(args[&#34;config&#34;]))

    for key, val in args.items():
        key = optvar(key, shadow_builtins=True)
        result[key.split(&#34;.&#34;)] = val
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="attrbox" href="index.html">attrbox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="attrbox.config.PYTHON_KEYWORDS" href="#attrbox.config.PYTHON_KEYWORDS">PYTHON_KEYWORDS</a></code></li>
<li><code><a title="attrbox.config.LoaderFunc" href="#attrbox.config.LoaderFunc">LoaderFunc</a></code></li>
<li><code><a title="attrbox.config.LOADERS" href="#attrbox.config.LOADERS">LOADERS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="attrbox.config.set_loader" href="#attrbox.config.set_loader">set_loader</a></code></li>
<li><code><a title="attrbox.config.load_config" href="#attrbox.config.load_config">load_config</a></code></li>
<li><code><a title="attrbox.config.optvar" href="#attrbox.config.optvar">optvar</a></code></li>
<li><code><a title="attrbox.config.parse_docopt" href="#attrbox.config.parse_docopt">parse_docopt</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>