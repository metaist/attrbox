<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>attrbox.env API documentation</title>
<meta name="description" content="Load configuration from environment files …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>attrbox.env</code></h1>
</header>
<section id="section-intro">
<p>Load configuration from environment files.</p>
<p>The file format is similar to a Bash file, but it is not as complete as
<a href="https://github.com/theskumar/python-dotenv#file-format">python-dotenv</a>.</p>
<p>Supported:</p>
<ul>
<li>unquoted and single-quoted key</li>
<li>unquoted, single- and double-quoted value</li>
<li>spaces before and after key, equal sign, and value are ignored</li>
<li><code>export</code> at the start of the line is ignored</li>
<li><code>#</code> comment at the start of the line</li>
<li>value expansion for values in the environment</li>
<li>value expansion for values only in the file (e.g., when <code>update_env=False</code>)</li>
</ul>
<p>Unsupported:</p>
<ul>
<li>key without a value</li>
<li>multiline value</li>
<li><code>#</code> comment after value</li>
<li>escape sequences in value</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; loads('''
... # a comment
... normal=value
... ' quoted '=&quot; space &quot;
... export expanded=&quot;expanded-${normal}&quot;
... ''')
{'normal': 'value', ' quoted ': ' space ', 'expanded': 'expanded-value'}
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Load configuration from environment files.

The file format is similar to a Bash file, but it is not as complete as
[python-dotenv](https://github.com/theskumar/python-dotenv#file-format).

Supported:

- unquoted and single-quoted key
- unquoted, single- and double-quoted value
- spaces before and after key, equal sign, and value are ignored
- `export` at the start of the line is ignored
- `#` comment at the start of the line
- value expansion for values in the environment
- value expansion for values only in the file (e.g., when `update_env=False`)

Unsupported:

- key without a value
- multiline value
- `#` comment after value
- escape sequences in value

Examples:
    &gt;&gt;&gt; loads(&#39;&#39;&#39;
    ... # a comment
    ... normal=value
    ... &#39; quoted &#39;=&#34; space &#34;
    ... export expanded=&#34;expanded-${normal}&#34;
    ... &#39;&#39;&#39;)
    {&#39;normal&#39;: &#39;value&#39;, &#39; quoted &#39;: &#39; space &#39;, &#39;expanded&#39;: &#39;expanded-value&#39;}
&#34;&#34;&#34;

# native
from os import environ as ENV
from pathlib import Path
from typing import Dict
from typing import Optional
from typing import Mapping
from typing import Protocol
from typing import Union
from typing import Match
import re

# pkg
from .attrdict import AttrDict

PathStr = Union[Path, str]
&#34;&#34;&#34;Type representing a `Path` or a string to a path.&#34;&#34;&#34;

_RE_EXPAND = re.compile(r&#34;\$(\w+|\{[^}]*\})&#34;, re.ASCII)
&#34;&#34;&#34;Regex for finding variable expansions.&#34;&#34;&#34;


class SupportsRead(Protocol):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Protocol for a class that implements a `.read()` method.&#34;&#34;&#34;

    def read(self) -&gt; str:
        &#34;&#34;&#34;Read the contents of the file-like object.&#34;&#34;&#34;


def expand(
    value: str,
    store: Optional[Mapping[str, str]] = None,
    *,
    dotted_keys: bool = False,
) -&gt; str:
    &#34;&#34;&#34;Expand variables of the form `$var` and `${var}`.

    A simplified form of `os.path.expandvars`.

    Args:
        value (str): value to expand

        store (Mapping[str, str], optional): valid substitutions.
            If `None`, `os.environ` is used. Defaults to `None`.

        dotted_keys (bool): if `True` allow `${dotted.name}` to map
            to nested values `{&#34;dotted&#34;: {&#34;name&#34;: &#34;value&#34;}}`.
            Defaults to `False`.

    Returns:
        str: expanded value. Unknown variables are left unchanged.

    Examples:
        Regular expansion works as expected:
        &gt;&gt;&gt; expand(&#34;$a ${b}&#34;, {&#39;a&#39;: &#39;hello&#39;, &#39;b&#39;: &#39;world&#39;})
        &#39;hello world&#39;

        Unknown variables are left unchanged:
        &gt;&gt;&gt; expand(&#34;$a is $b&#34;, {&#39;a&#39;: &#39;this&#39;})
        &#39;this is $b&#39;
        &gt;&gt;&gt; expand(&#34;no vars&#34;, {})
        &#39;no vars&#39;

        Values are passed to `str`:
        &gt;&gt;&gt; expand(&#34;$a&#34;, {&#39;a&#39;: 5})
        &#39;5&#39;

        Dotted names are optionally possible:
        &gt;&gt;&gt; expand(&#34;${a.b}&#34;, {&#34;a&#34;: {&#34;b&#34;: &#34;works&#34;}}, dotted_keys=True)
        &#39;works&#39;
    &#34;&#34;&#34;
    if &#34;$&#34; not in value:
        return value

    values = store or ENV

    if dotted_keys and not isinstance(values, AttrDict):
        values = AttrDict(values)

    def _repl(match: Match[str]) -&gt; str:
        value = match.group(0)
        name = match.group(1)
        if name.startswith(&#34;{&#34;) and name.endswith(&#34;}&#34;):
            name = name[1:-1]

        if dotted_keys:
            name = name.split(&#34;.&#34;)

        if name in values:
            value = str(values[name])
        return value

    return _RE_EXPAND.sub(_repl, value)


def load(
    file: SupportsRead,
    /,
    *,
    update_env: bool = True,
    dotted_keys: bool = True,
) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Load an environment `file`.

    Args:
        file (SupportsRead): file-like (has `.read()`).

        update_env (bool, optional): If `True`, update the `os.path.environ` as
            values are read in. Defaults to `True`.

        dotted_keys (bool, optional): If `True`, split the key by `.` and use that
            to create a nested `dict`. Defaults to `True`.

    Returns:
        Dict[str, str]: configuration values

    Examples:
        &gt;&gt;&gt; root = Path(__file__).parent.parent.parent
        &gt;&gt;&gt; load((root / &#34;test/config_3.env&#34;).open())
        {&#39;section&#39;: {&#39;key&#39;: &#39;value3&#39;, &#39;env&#39;: &#39;loaded&#39;}}
    &#34;&#34;&#34;
    return loads(file.read(), update_env=update_env, dotted_keys=dotted_keys)


def loads(
    text: str,
    /,
    *,
    update_env: bool = True,
    dotted_keys: bool = True,
) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Parse an environment file from a string.

    Args:
        text (str): text to parse.

        update_env (bool, optional): If `True`, update the `os.path.environ` as
            values are read in. Defaults to `True`.

        dotted_keys (bool, optional): If `True`, split the key by `.` and use that
            to create a nested `dict`. Defaults to `True`.

    Returns:
        Dict[str, str]: configuration values

    Examples:
        If you don&#39;t want to update the environment:
        &gt;&gt;&gt; &#39;fake&#39; in ENV
        False
        &gt;&gt;&gt; loads(&#39;&#39;&#39;export &#39;fake&#39;=ignored
        ... works=not $fake&#39;&#39;&#39;, update_env=False)
        {&#39;fake&#39;: &#39;ignored&#39;, &#39;works&#39;: &#39;not ignored&#39;}
        &gt;&gt;&gt; &#39;fake&#39; in ENV
        False

        Keys with dots in them create nested dicts, but are optional:
        &gt;&gt;&gt; loads(&#39;section.key=value&#39;, update_env=False, dotted_keys=True)
        {&#39;section&#39;: {&#39;key&#39;: &#39;value&#39;}}
        &gt;&gt;&gt; loads(&#39;section.key=value&#39;, update_env=False, dotted_keys=False)
        {&#39;section.key&#39;: &#39;value&#39;}
    &#34;&#34;&#34;
    result = AttrDict()
    for line in text.replace(&#34;\r\n&#34;, &#34;\n&#34;).split(&#34;\n&#34;):
        line = line.strip()
        if not line or line.startswith(&#34;#&#34;):
            continue  # skip blank lines and comments

        if line.startswith(&#34;export &#34;):
            line = line[len(&#34;export &#34;) :]

        key, value = line.split(&#34;=&#34;, 1)

        key = key.strip()
        if len(key) &gt;= 2 and key.startswith(&#34;&#39;&#34;) and key.endswith(&#34;&#39;&#34;):
            key = key[1:-1]  # unquote key

        # We expand the value with the current values which may have
        # nested structure and then with the environment values (which do not).
        value = expand(value, result, dotted_keys=dotted_keys)
        value = expand(value)

        value = value.strip()
        if len(value) &gt;= 2 and (
            (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;))
            or (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;))
        ):
            value = value[1:-1]  # unquote value

        if update_env:
            ENV[key] = value
        if dotted_keys:
            result[key.split(&#34;.&#34;)] = value
        else:
            result[key] = value
    return result


def find_env(path: Optional[PathStr] = None, name: str = &#34;.env&#34;) -&gt; Optional[Path]:
    &#34;&#34;&#34;Find the `.env` file in the ancestors of the current path.

    Args:
        path (PathLike, optional): A starting path to check. If `None`, starts with
            the current working directory. Defaults to `None`.
        name (str, optional): file name to search for. Defaults to `&#34;.env&#34;`.

    Returns:
        Optional[Path]: path to environment file or `None` if it is not found.

    Examples:
        Search from the current working directory:
        &gt;&gt;&gt; str(find_env())
        &#39;.../.env&#39;

        Search from a specific directory:
        &gt;&gt;&gt; str(find_env(&#34;.&#34;))
        &#39;.../.env&#39;

        Pass a `Path` object:
        &gt;&gt;&gt; str(find_env(Path(__file__)))
        &#39;.../.env&#39;

        Point directly to the `.env` file:
        &gt;&gt;&gt; str(find_env(Path(__file__).parent.parent.parent / &#34;.env&#34;))
        &#39;.../.env&#39;
    &#34;&#34;&#34;
    if not path:
        path = Path.cwd()
    elif isinstance(path, str):
        path = Path(path).resolve()

    if path.name == name and path.exists():
        return path

    for parent in [path] + list(path.parents):
        path = parent / name
        if path.exists():
            return path
    return None


def load_env(path: Optional[PathStr] = None) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Load an environment file.

    We recursively search for a `.env` file from the path given or the current
    working directory, if omitted.

    Args:
        path (PathStr, optional): starting path. If `None`, start from the
            current working directory. Defaults to `None`.

    Raises:
        FileNotFoundError: If not `.env` file is found.

    Returns:
        Dict[str, str]: configuration values

    Examples:
        &gt;&gt;&gt; load_env() # our .env doesn&#39;t have any values
        {}

        If no `.env` can be found, a `FileNotFoundError` is raised:
        &gt;&gt;&gt; load_env(&#34;/&#34;)
        Traceback (most recent call last):
            ...
        FileNotFoundError: Cannot find .env file to load.
    &#34;&#34;&#34;
    path = find_env(path)
    if not path or not path.exists():
        raise FileNotFoundError(&#34;Cannot find .env file to load.&#34;)
    return loads(path.read_text(encoding=&#34;utf-8&#34;), update_env=True, dotted_keys=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="attrbox.env.PathStr"><code class="name">var <span class="ident">PathStr</span></code></dt>
<dd>
<div class="desc"><p>Type representing a <code>Path</code> or a string to a path.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="attrbox.env.expand"><code class="name flex">
<span>def <span class="ident">expand</span></span>(<span>value: str, store: Optional[Mapping[str, str]] = None, *, dotted_keys: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Expand variables of the form <code>$var</code> and <code>${var}</code>.</p>
<p>A simplified form of <code>os.path.expandvars</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>value to expand</dd>
<dt><strong><code>store</code></strong> :&ensp;<code>Mapping[str, str]</code>, optional</dt>
<dd>valid substitutions.
If <code>None</code>, <code>os.environ</code> is used. Defaults to <code>None</code>.</dd>
<dt><strong><code>dotted_keys</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code> allow <code>${dotted.name}</code> to map
to nested values <code>{"dotted": {"name": "value"}}</code>.
Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>expanded value. Unknown variables are left unchanged.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Regular expansion works as expected:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; expand(&quot;$a ${b}&quot;, {'a': 'hello', 'b': 'world'})
'hello world'
</code></pre>
<p>Unknown variables are left unchanged:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; expand(&quot;$a is $b&quot;, {'a': 'this'})
'this is $b'
&gt;&gt;&gt; expand(&quot;no vars&quot;, {})
'no vars'
</code></pre>
<p>Values are passed to <code>str</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; expand(&quot;$a&quot;, {'a': 5})
'5'
</code></pre>
<p>Dotted names are optionally possible:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; expand(&quot;${a.b}&quot;, {&quot;a&quot;: {&quot;b&quot;: &quot;works&quot;}}, dotted_keys=True)
'works'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand(
    value: str,
    store: Optional[Mapping[str, str]] = None,
    *,
    dotted_keys: bool = False,
) -&gt; str:
    &#34;&#34;&#34;Expand variables of the form `$var` and `${var}`.

    A simplified form of `os.path.expandvars`.

    Args:
        value (str): value to expand

        store (Mapping[str, str], optional): valid substitutions.
            If `None`, `os.environ` is used. Defaults to `None`.

        dotted_keys (bool): if `True` allow `${dotted.name}` to map
            to nested values `{&#34;dotted&#34;: {&#34;name&#34;: &#34;value&#34;}}`.
            Defaults to `False`.

    Returns:
        str: expanded value. Unknown variables are left unchanged.

    Examples:
        Regular expansion works as expected:
        &gt;&gt;&gt; expand(&#34;$a ${b}&#34;, {&#39;a&#39;: &#39;hello&#39;, &#39;b&#39;: &#39;world&#39;})
        &#39;hello world&#39;

        Unknown variables are left unchanged:
        &gt;&gt;&gt; expand(&#34;$a is $b&#34;, {&#39;a&#39;: &#39;this&#39;})
        &#39;this is $b&#39;
        &gt;&gt;&gt; expand(&#34;no vars&#34;, {})
        &#39;no vars&#39;

        Values are passed to `str`:
        &gt;&gt;&gt; expand(&#34;$a&#34;, {&#39;a&#39;: 5})
        &#39;5&#39;

        Dotted names are optionally possible:
        &gt;&gt;&gt; expand(&#34;${a.b}&#34;, {&#34;a&#34;: {&#34;b&#34;: &#34;works&#34;}}, dotted_keys=True)
        &#39;works&#39;
    &#34;&#34;&#34;
    if &#34;$&#34; not in value:
        return value

    values = store or ENV

    if dotted_keys and not isinstance(values, AttrDict):
        values = AttrDict(values)

    def _repl(match: Match[str]) -&gt; str:
        value = match.group(0)
        name = match.group(1)
        if name.startswith(&#34;{&#34;) and name.endswith(&#34;}&#34;):
            name = name[1:-1]

        if dotted_keys:
            name = name.split(&#34;.&#34;)

        if name in values:
            value = str(values[name])
        return value

    return _RE_EXPAND.sub(_repl, value)</code></pre>
</details>
</dd>
<dt id="attrbox.env.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>file: <a title="attrbox.env.SupportsRead" href="#attrbox.env.SupportsRead">SupportsRead</a>, /, *, update_env: bool = True, dotted_keys: bool = True) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Load an environment <code>file</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code><a title="attrbox.env.SupportsRead" href="#attrbox.env.SupportsRead">SupportsRead</a></code></dt>
<dd>file-like (has <code>.read()</code>).</dd>
<dt><strong><code>update_env</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, update the <code>os.path.environ</code> as
values are read in. Defaults to <code>True</code>.</dd>
<dt><strong><code>dotted_keys</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, split the key by <code>.</code> and use that
to create a nested <code>dict</code>. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>configuration values</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; root = Path(__file__).parent.parent.parent
&gt;&gt;&gt; load((root / &quot;test/config_3.env&quot;).open())
{'section': {'key': 'value3', 'env': 'loaded'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(
    file: SupportsRead,
    /,
    *,
    update_env: bool = True,
    dotted_keys: bool = True,
) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Load an environment `file`.

    Args:
        file (SupportsRead): file-like (has `.read()`).

        update_env (bool, optional): If `True`, update the `os.path.environ` as
            values are read in. Defaults to `True`.

        dotted_keys (bool, optional): If `True`, split the key by `.` and use that
            to create a nested `dict`. Defaults to `True`.

    Returns:
        Dict[str, str]: configuration values

    Examples:
        &gt;&gt;&gt; root = Path(__file__).parent.parent.parent
        &gt;&gt;&gt; load((root / &#34;test/config_3.env&#34;).open())
        {&#39;section&#39;: {&#39;key&#39;: &#39;value3&#39;, &#39;env&#39;: &#39;loaded&#39;}}
    &#34;&#34;&#34;
    return loads(file.read(), update_env=update_env, dotted_keys=dotted_keys)</code></pre>
</details>
</dd>
<dt id="attrbox.env.loads"><code class="name flex">
<span>def <span class="ident">loads</span></span>(<span>text: str, /, *, update_env: bool = True, dotted_keys: bool = True) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse an environment file from a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text to parse.</dd>
<dt><strong><code>update_env</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, update the <code>os.path.environ</code> as
values are read in. Defaults to <code>True</code>.</dd>
<dt><strong><code>dotted_keys</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, split the key by <code>.</code> and use that
to create a nested <code>dict</code>. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>configuration values</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>If you don't want to update the environment:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; 'fake' in ENV
False
&gt;&gt;&gt; loads('''export 'fake'=ignored
... works=not $fake''', update_env=False)
{'fake': 'ignored', 'works': 'not ignored'}
&gt;&gt;&gt; 'fake' in ENV
False
</code></pre>
<p>Keys with dots in them create nested dicts, but are optional:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; loads('section.key=value', update_env=False, dotted_keys=True)
{'section': {'key': 'value'}}
&gt;&gt;&gt; loads('section.key=value', update_env=False, dotted_keys=False)
{'section.key': 'value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loads(
    text: str,
    /,
    *,
    update_env: bool = True,
    dotted_keys: bool = True,
) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Parse an environment file from a string.

    Args:
        text (str): text to parse.

        update_env (bool, optional): If `True`, update the `os.path.environ` as
            values are read in. Defaults to `True`.

        dotted_keys (bool, optional): If `True`, split the key by `.` and use that
            to create a nested `dict`. Defaults to `True`.

    Returns:
        Dict[str, str]: configuration values

    Examples:
        If you don&#39;t want to update the environment:
        &gt;&gt;&gt; &#39;fake&#39; in ENV
        False
        &gt;&gt;&gt; loads(&#39;&#39;&#39;export &#39;fake&#39;=ignored
        ... works=not $fake&#39;&#39;&#39;, update_env=False)
        {&#39;fake&#39;: &#39;ignored&#39;, &#39;works&#39;: &#39;not ignored&#39;}
        &gt;&gt;&gt; &#39;fake&#39; in ENV
        False

        Keys with dots in them create nested dicts, but are optional:
        &gt;&gt;&gt; loads(&#39;section.key=value&#39;, update_env=False, dotted_keys=True)
        {&#39;section&#39;: {&#39;key&#39;: &#39;value&#39;}}
        &gt;&gt;&gt; loads(&#39;section.key=value&#39;, update_env=False, dotted_keys=False)
        {&#39;section.key&#39;: &#39;value&#39;}
    &#34;&#34;&#34;
    result = AttrDict()
    for line in text.replace(&#34;\r\n&#34;, &#34;\n&#34;).split(&#34;\n&#34;):
        line = line.strip()
        if not line or line.startswith(&#34;#&#34;):
            continue  # skip blank lines and comments

        if line.startswith(&#34;export &#34;):
            line = line[len(&#34;export &#34;) :]

        key, value = line.split(&#34;=&#34;, 1)

        key = key.strip()
        if len(key) &gt;= 2 and key.startswith(&#34;&#39;&#34;) and key.endswith(&#34;&#39;&#34;):
            key = key[1:-1]  # unquote key

        # We expand the value with the current values which may have
        # nested structure and then with the environment values (which do not).
        value = expand(value, result, dotted_keys=dotted_keys)
        value = expand(value)

        value = value.strip()
        if len(value) &gt;= 2 and (
            (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;))
            or (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;))
        ):
            value = value[1:-1]  # unquote value

        if update_env:
            ENV[key] = value
        if dotted_keys:
            result[key.split(&#34;.&#34;)] = value
        else:
            result[key] = value
    return result</code></pre>
</details>
</dd>
<dt id="attrbox.env.find_env"><code class="name flex">
<span>def <span class="ident">find_env</span></span>(<span>path: Union[pathlib.Path, str, None] = None, name: str = '.env') ‑> Optional[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the <code>.env</code> file in the ancestors of the current path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>PathLike</code>, optional</dt>
<dd>A starting path to check. If <code>None</code>, starts with
the current working directory. Defaults to <code>None</code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>file name to search for. Defaults to <code>".env"</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[Path]</code></dt>
<dd>path to environment file or <code>None</code> if it is not found.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Search from the current working directory:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; str(find_env())
'.../.env'
</code></pre>
<p>Search from a specific directory:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; str(find_env(&quot;.&quot;))
'.../.env'
</code></pre>
<p>Pass a <code>Path</code> object:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; str(find_env(Path(__file__)))
'.../.env'
</code></pre>
<p>Point directly to the <code>.env</code> file:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; str(find_env(Path(__file__).parent.parent.parent / &quot;.env&quot;))
'.../.env'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_env(path: Optional[PathStr] = None, name: str = &#34;.env&#34;) -&gt; Optional[Path]:
    &#34;&#34;&#34;Find the `.env` file in the ancestors of the current path.

    Args:
        path (PathLike, optional): A starting path to check. If `None`, starts with
            the current working directory. Defaults to `None`.
        name (str, optional): file name to search for. Defaults to `&#34;.env&#34;`.

    Returns:
        Optional[Path]: path to environment file or `None` if it is not found.

    Examples:
        Search from the current working directory:
        &gt;&gt;&gt; str(find_env())
        &#39;.../.env&#39;

        Search from a specific directory:
        &gt;&gt;&gt; str(find_env(&#34;.&#34;))
        &#39;.../.env&#39;

        Pass a `Path` object:
        &gt;&gt;&gt; str(find_env(Path(__file__)))
        &#39;.../.env&#39;

        Point directly to the `.env` file:
        &gt;&gt;&gt; str(find_env(Path(__file__).parent.parent.parent / &#34;.env&#34;))
        &#39;.../.env&#39;
    &#34;&#34;&#34;
    if not path:
        path = Path.cwd()
    elif isinstance(path, str):
        path = Path(path).resolve()

    if path.name == name and path.exists():
        return path

    for parent in [path] + list(path.parents):
        path = parent / name
        if path.exists():
            return path
    return None</code></pre>
</details>
</dd>
<dt id="attrbox.env.load_env"><code class="name flex">
<span>def <span class="ident">load_env</span></span>(<span>path: Union[pathlib.Path, str, None] = None) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Load an environment file.</p>
<p>We recursively search for a <code>.env</code> file from the path given or the current
working directory, if omitted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code><a title="attrbox.env.PathStr" href="#attrbox.env.PathStr">PathStr</a></code>, optional</dt>
<dd>starting path. If <code>None</code>, start from the
current working directory. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If not <code>.env</code> file is found.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>configuration values</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; load_env() # our .env doesn't have any values
{}
</code></pre>
<p>If no <code>.env</code> can be found, a <code>FileNotFoundError</code> is raised:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; load_env(&quot;/&quot;)
Traceback (most recent call last):
    ...
FileNotFoundError: Cannot find .env file to load.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_env(path: Optional[PathStr] = None) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Load an environment file.

    We recursively search for a `.env` file from the path given or the current
    working directory, if omitted.

    Args:
        path (PathStr, optional): starting path. If `None`, start from the
            current working directory. Defaults to `None`.

    Raises:
        FileNotFoundError: If not `.env` file is found.

    Returns:
        Dict[str, str]: configuration values

    Examples:
        &gt;&gt;&gt; load_env() # our .env doesn&#39;t have any values
        {}

        If no `.env` can be found, a `FileNotFoundError` is raised:
        &gt;&gt;&gt; load_env(&#34;/&#34;)
        Traceback (most recent call last):
            ...
        FileNotFoundError: Cannot find .env file to load.
    &#34;&#34;&#34;
    path = find_env(path)
    if not path or not path.exists():
        raise FileNotFoundError(&#34;Cannot find .env file to load.&#34;)
    return loads(path.read_text(encoding=&#34;utf-8&#34;), update_env=True, dotted_keys=True)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="attrbox.env.SupportsRead"><code class="flex name class">
<span>class <span class="ident">SupportsRead</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for a class that implements a <code>.read()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SupportsRead(Protocol):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Protocol for a class that implements a `.read()` method.&#34;&#34;&#34;

    def read(self) -&gt; str:
        &#34;&#34;&#34;Read the contents of the file-like object.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="attrbox.env.SupportsRead.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Read the contents of the file-like object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; str:
    &#34;&#34;&#34;Read the contents of the file-like object.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="attrbox" href="index.html">attrbox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="attrbox.env.PathStr" href="#attrbox.env.PathStr">PathStr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="attrbox.env.expand" href="#attrbox.env.expand">expand</a></code></li>
<li><code><a title="attrbox.env.load" href="#attrbox.env.load">load</a></code></li>
<li><code><a title="attrbox.env.loads" href="#attrbox.env.loads">loads</a></code></li>
<li><code><a title="attrbox.env.find_env" href="#attrbox.env.find_env">find_env</a></code></li>
<li><code><a title="attrbox.env.load_env" href="#attrbox.env.load_env">load_env</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="attrbox.env.SupportsRead" href="#attrbox.env.SupportsRead">SupportsRead</a></code></h4>
<ul class="">
<li><code><a title="attrbox.env.SupportsRead.read" href="#attrbox.env.SupportsRead.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>